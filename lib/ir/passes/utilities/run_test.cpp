// Copyright (c) 2025 0x676e616c63
// SPDX-License-Identifier: MIT

#include "ir/passes/utilities/run_test.hpp"
#include "config/config.hpp"
#include "ir/passes/transforms/namenormalizer.hpp"
#include "utils/test.hpp"

#include "ir/passes/utilities/irprinter.hpp"

#include <filesystem>
#include <fstream>

namespace IR {
namespace fs = std::filesystem;

void RunTestPass::runImpl(const std::string& outfile_id, Module& module) {
    Err::gassert(!expected_out_path.empty(), "Missing expected output");
    Err::gassert(fs::exists(expected_out_path), "Expected output not found");
    Err::gassert(input_path.empty() || fs::exists(input_path), "Input file not found");

    std::string temp_dir = Config::IR::RUN_TEST_TEMP_DIR;

    if (!fs::exists(temp_dir))
        fs::create_directories(temp_dir);

    auto sylib = temp_dir + "/sylib.ll";
    // Same as test/include/runner.hpp
    if (!fs::exists(sylib)) {
        Err::gassert(!sylib_src_path.empty(), "Missing sylib.c");
        Err::gassert(fs::exists(sylib_src_path), "sylib.c not found");

        // Just a quick and dirty trick to silence llvm-link.
        // llvm-link will emit a warning if we link two modules of different
        // data layouts Given that the LLVM IR we generate contains no target
        // data layout, we use `sed` to delete 'target datalayout' from the
        // sylib.ll generated by clang.
        auto sylib_command =
            "clang -S -emit-llvm " + sylib_src_path + " -o " + sylib + " && sed '/^target datalayout/d' -i " + sylib;

        Logger::logInfo("[RunTest]: Running '", sylib_command, "'.");
        std::system(sylib_command.c_str());
    }

    auto outsource = temp_dir + "/" + outfile_id + ".ll";

    std::ofstream outsouce_stream(outsource);
    Err::gassert(outsouce_stream.good(), "Cannot open '" + outsource + "'.");
    PrintModulePass printer(outsouce_stream);
    NameNormalizePass name_normalizer(true);
    module.accept(name_normalizer);
    module.accept(printer);

    auto outtime = temp_dir + "/" + outfile_id + ".time";
    auto output = temp_dir + "/" + outfile_id + ".out";
    auto linked_outbc = temp_dir + "/" + outfile_id + ".bc";

    auto link_command = "llvm-link " + sylib + " " + outsource + " -o " + linked_outbc;
    Logger::logInfo("[RunTest]: Running '", link_command, "'.");
    std::system(link_command.c_str());

    // /bin/echo is the one in GNU coreutils
    // Not the one in sh or bash.
    auto exec_command = "lli " + linked_outbc + " < " + (!input_path.empty() ? input_path : "/dev/null") + " > " +
                        output + " 2>" + outtime + R"(;/bin/echo -e "\n"$? >> )" + output;

    Logger::logInfo("[RunTest]: Running '", exec_command, "'.");
    std::system(exec_command.c_str());

    auto syout = Test::readFile(output);
    Test::fixNewline(syout);
    auto time_elapsed = Test::parseTime(Test::readFile(outtime));

    auto expected_out = Test::readFile(expected_out_path);
    Test::fixNewline(expected_out);

    if (syout != expected_out) {
        Logger::logCritical("[RunTest]: Expected output: '",
                            expected_out.size() > 1024 ? "<too long to display>" : expected_out, "', but got: '",
                            syout.size() > 1024 ? "<too long to display>" : syout, "'.");
        Logger::logCritical("[RunTest]: Test failed in ", time_elapsed, "us.");
        if (abort_when_test_failed)
            std::abort();
    } else
        Logger::logInfo("[RunTest]: Test passed in ", time_elapsed, "us.");
}

PM::PreservedAnalyses RunTestPass::run(Function &function, FAM &fam) {
    static size_t name_cnt = 0;
    auto outfile_id = function.getName().substr(1) // eat '@'
                  + "_" + std::to_string(name_cnt++);
    runImpl(outfile_id, *function.getParent());
    return PreserveAll();
}
PM::PreservedAnalyses RunTestPass::run(Module &module, MAM &manager) {
    runImpl("gnalc_module", module);
    return PreserveAll();
}
} // namespace IR
